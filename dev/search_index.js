var documenterSearchIndex = {"docs":
[{"location":"api/#api-reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#chirp-api","page":"API Reference","title":"Chirp Correction","text":"","category":"section"},{"location":"api/#SVD-Filtering","page":"API Reference","title":"SVD Filtering","text":"","category":"section"},{"location":"api/#Peak-Fitting","page":"API Reference","title":"Peak Fitting","text":"","category":"section"},{"location":"api/#Peak-Detection","page":"API Reference","title":"Peak Detection","text":"","category":"section"},{"location":"api/#Exponential-Decay-Fitting","page":"API Reference","title":"Exponential Decay Fitting","text":"","category":"section"},{"location":"api/#Baseline-Correction","page":"API Reference","title":"Baseline Correction","text":"","category":"section"},{"location":"api/#Spectroscopy-Utilities","page":"API Reference","title":"Spectroscopy Utilities","text":"","category":"section"},{"location":"api/#Unit-Conversions","page":"API Reference","title":"Unit Conversions","text":"","category":"section"},{"location":"api/#SpectroscopyTools.SpectroscopyTools","page":"API Reference","title":"SpectroscopyTools.SpectroscopyTools","text":"SpectroscopyTools.jl — General-purpose spectroscopy analysis toolkit.\n\nProvides data types, fitting routines, baseline correction, peak detection, unit conversions, and utility functions for spectroscopic data analysis.\n\nExtracted from QPS.jl to serve as a standalone, reusable foundation.\n\n\n\n\n\n","category":"module"},{"location":"api/#SpectroscopyTools.AbstractSpectroscopyData","page":"API Reference","title":"SpectroscopyTools.AbstractSpectroscopyData","text":"AbstractSpectroscopyData\n\nAbstract base type for all spectroscopy data types.\n\nSubtypes must implement the following interface:\n\nxdata(d) — Primary x-axis data (Vector{Float64})\nydata(d) — Signal data (Vector{Float64}) or secondary axis for 2D\nzdata(d) — Matrix data for 2D types, nothing for 1D\nxlabel(d) — X-axis label string\nylabel(d) — Y-axis or signal label string\nis_matrix(d) — Whether data is 2D (returns Bool)\n\nOptional (have defaults):\n\nsource_file(d) — Source filename (default: \"\")\nnpoints(d) — Number of data points (default: length(xdata(d)), tuple for 2D)\ntitle(d) — Display title (default: source_file(d))\n\nThis enables uniform handling in data viewers and plotting functions while maintaining semantic field names in each concrete type.\n\nExample\n\n# Works for any spectroscopy data type\nfunction plot_data(data::AbstractSpectroscopyData)\n    if is_matrix(data)\n        heatmap(xdata(data), ydata(data), zdata(data)')\n    else\n        lines(xdata(data), ydata(data))\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#SpectroscopyTools.TATrace","page":"API Reference","title":"SpectroscopyTools.TATrace","text":"TATrace <: AbstractSpectroscopyData\n\nSingle-wavelength transient absorption kinetic trace.\n\nFields\n\ntime::Vector{Float64}: Time axis (ps)\nsignal::Vector{Float64}: ΔA signal\nwavelength::Float64: Probe wavelength, NaN if unknown\nmetadata::Dict{Symbol,Any}: Additional info\n\n\n\n\n\n","category":"type"},{"location":"api/#SpectroscopyTools.TASpectrum","page":"API Reference","title":"SpectroscopyTools.TASpectrum","text":"TASpectrum <: AbstractSpectroscopyData\n\nTransient absorption spectrum at a fixed time delay.\n\nFields\n\nwavenumber::Vector{Float64}: Wavenumber axis (cm⁻¹)\nsignal::Vector{Float64}: ΔA signal\ntime_delay::Float64: Time delay (ps), NaN if unknown\nmetadata::Dict{Symbol,Any}: Additional info\n\n\n\n\n\n","category":"type"},{"location":"api/#SpectroscopyTools.TAMatrix","page":"API Reference","title":"SpectroscopyTools.TAMatrix","text":"TAMatrix <: AbstractSpectroscopyData\n\nTwo-dimensional transient absorption data (time x wavelength).\n\nFields\n\ntime::Vector{Float64}: Time axis (ps)\nwavelength::Vector{Float64}: Wavelength axis (nm) or wavenumber (cm⁻¹)\ndata::Matrix{Float64}: ΔA signal matrix, size (ntime, nwavelength)\nmetadata::Dict{Symbol,Any}: Additional info\n\nIndexing\n\nmatrix[λ=800]     # Extract TATrace at λ ≈ 800 nm\nmatrix[t=1.0]     # Extract TASpectrum at t ≈ 1.0 ps\n\n\n\n\n\n","category":"type"},{"location":"api/#SpectroscopyTools.TASpectrumFit","page":"API Reference","title":"SpectroscopyTools.TASpectrumFit","text":"TASpectrumFit\n\nResult of TA spectrum fitting with N peaks of arbitrary lineshape.\n\nSupports any combination of ESA, GSB, and SE peaks, each with its own lineshape model (Gaussian, Lorentzian, pseudo-Voigt).\n\nAccess peaks\n\nresult.peaks — Vector of TAPeak\nresult[i] — i-th peak\nresult[:esa] — first peak with label :esa\nanharmonicity(result) — GSB center minus ESA center (NaN if not applicable)\n\nFields\n\npeaks::Vector{TAPeak} — Fitted peak parameters\noffset, rsquared, residuals — Fit metadata\n\n\n\n\n\n","category":"type"},{"location":"api/#SpectroscopyTools.TAPeak","page":"API Reference","title":"SpectroscopyTools.TAPeak","text":"TAPeak\n\nInformation about a single peak in a TA spectrum fit.\n\nFields\n\nlabel::Symbol — Peak type (:esa, :gsb, :se, :positive, :negative)\nmodel::String — Lineshape model name (\"gaussian\", \"lorentzian\", \"pseudo_voigt\")\ncenter::Float64 — Peak center position\nwidth::Float64 — Width parameter (sigma for gaussian/voigt, fwhm for lorentzian)\namplitude::Float64 — Peak amplitude (always positive; sign determined by label)\n\n\n\n\n\n","category":"type"},{"location":"api/#SpectroscopyTools.ChirpCalibration","page":"API Reference","title":"SpectroscopyTools.ChirpCalibration","text":"ChirpCalibration\n\nStores the result of chirp detection: detected chirp points, polynomial fit, and detection parameters for reproducibility.\n\nFields\n\nwavelength: Wavelength points where chirp was detected (nm)\ntime_offset: Detected chirp time at each wavelength (ps)\npoly_coeffs: Polynomial fit coefficients (constant term first, ascending order)\npoly_order: Polynomial order used\nreference_λ: Reference wavelength where chirp = 0 (nm)\nr_squared: Polynomial fit quality\nmetadata: Detection parameters for reproducibility\n\n\n\n\n\n","category":"type"},{"location":"api/#SpectroscopyTools.detect_chirp","page":"API Reference","title":"SpectroscopyTools.detect_chirp","text":"detect_chirp(matrix::TAMatrix; kwargs...) -> ChirpCalibration\n\nDetect chirp (GVD) in a broadband TA matrix via cross-correlation (:xcorr) or threshold crossing (:threshold). Returns a ChirpCalibration with polynomial fit.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.correct_chirp","page":"API Reference","title":"SpectroscopyTools.correct_chirp","text":"correct_chirp(matrix::TAMatrix, cal::ChirpCalibration) -> TAMatrix\n\nApply chirp correction via cubic spline interpolation, shifting each wavelength column by t_shift(λ) from the calibration polynomial.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.subtract_background","page":"API Reference","title":"SpectroscopyTools.subtract_background","text":"subtract_background(matrix::TAMatrix; t_range=nothing) -> TAMatrix\n\nSubtract pre-pump background from a TA matrix by averaging and removing the signal in the baseline region (before pump arrival).\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.polynomial","page":"API Reference","title":"SpectroscopyTools.polynomial","text":"polynomial(cal::ChirpCalibration) -> Function\n\nReturn a callable polynomial t_shift = poly(λ) from the calibration. Coefficients are in ascending order: c[1] + c[2]*λ + c[3]*λ² + ...\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.save_chirp","page":"API Reference","title":"SpectroscopyTools.save_chirp","text":"save_chirp(path::String, cal::ChirpCalibration)\n\nSave a chirp calibration to a JSON file.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.load_chirp","page":"API Reference","title":"SpectroscopyTools.load_chirp","text":"load_chirp(path::String) -> ChirpCalibration\n\nLoad a chirp calibration from a JSON file.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.svd_filter","page":"API Reference","title":"SpectroscopyTools.svd_filter","text":"svd_filter(matrix::TAMatrix; n_components::Int=5) -> TAMatrix\n\nDenoise a TA matrix by keeping only the first n_components singular value components. Higher-order components (dominated by noise) are discarded.\n\nThis is a standard preprocessing step for broadband TA data. Typical usage: denoise first, then subtract background, detect chirp, and correct chirp.\n\nArguments\n\nmatrix::TAMatrix: Input time × wavelength ΔA matrix\n\nKeywords\n\nn_components::Int=5: Number of singular value components to retain. Use singular_values to inspect the spectrum and choose.\n\nReturns\n\nA new TAMatrix with filtered data. Metadata includes :svd_filtered => true and :svd_n_components => n_components.\n\nExamples\n\nsv = singular_values(matrix)  # inspect singular value spectrum\nfiltered = svd_filter(matrix; n_components=3)\n\n\n\n\n\nsvd_filter(x::AbstractVector, y::AbstractVector, data::AbstractMatrix;\n           n_components::Int=5) -> Matrix{Float64}\n\nDenoise a raw data matrix by keeping only the first n_components singular value components. Returns the filtered matrix.\n\nArguments\n\nx: First axis (e.g., time)\ny: Second axis (e.g., wavelength)\ndata: Matrix of size (length(x), length(y))\n\nKeywords\n\nn_components::Int=5: Number of components to retain\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.singular_values","page":"API Reference","title":"SpectroscopyTools.singular_values","text":"singular_values(matrix::TAMatrix) -> Vector{Float64}\n\nReturn the singular values of the TA data matrix. Inspect these to choose n_components for svd_filter — look for a gap between signal and noise components.\n\nExamples\n\nsv = singular_values(matrix)\n# Plot sv to find the elbow, then filter:\nfiltered = svd_filter(matrix; n_components=3)\n\n\n\n\n\nsingular_values(data::AbstractMatrix) -> Vector{Float64}\n\nReturn the singular values of a raw data matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.fit_peaks","page":"API Reference","title":"SpectroscopyTools.fit_peaks","text":"fit_peaks(x, y; kwargs...) -> MultiPeakFitResult\nfit_peaks(spec::AbstractSpectroscopyData, region; kwargs...) -> MultiPeakFitResult\nfit_peaks(spec::AbstractSpectroscopyData; kwargs...) -> MultiPeakFitResult\n\nFit one or more peaks in spectroscopy data.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.fit_ta_spectrum","page":"API Reference","title":"SpectroscopyTools.fit_ta_spectrum","text":"fit_ta_spectrum(spec::TASpectrum; kwargs...) -> TASpectrumFit\n\nFit a transient absorption spectrum with N peaks of arbitrary lineshape.\n\nUses find_peaks to automatically detect initial peak positions from the data, so multiple well-separated peaks of the same type (e.g., three GSB peaks for W(CO)₆) are initialized correctly.\n\nKeywords\n\npeaks=[:esa, :gsb] — Peak types. Each element is either a Symbol (:esa, :gsb, :se, :positive, :negative) or a (Symbol, Function) tuple specifying label and lineshape model.\nmodel=gaussian — Default lineshape for peaks specified as symbols only.\nregion=nothing — Optional (x_min, x_max) fitting region.\nfit_offset=false — Whether to fit a constant offset.\np0=nothing — Manual initial parameter vector. Overrides automatic detection.\n\nPeak signs\n\n:esa, :positive → +1 (positive ΔA)\n:gsb, :se, :negative → -1 (negative ΔA)\n\nExamples\n\n# Default: 1 Gaussian ESA + 1 Gaussian GSB\nresult = fit_ta_spectrum(spec)\n\n# Three GSB peaks (e.g., W(CO)₆ carbonyl stretches)\nresult = fit_ta_spectrum(spec; peaks=[:esa, :esa, :esa, :gsb, :gsb, :gsb])\n\n# Per-peak lineshapes\nresult = fit_ta_spectrum(spec; peaks=[(:esa, lorentzian), (:gsb, gaussian)])\n\n# Access results\nresult[:esa].center      # first ESA peak\nresult[2].center         # second peak by index\nanharmonicity(result)    # GSB - ESA center (only if exactly 1 of each)\npredict(result, ν)       # full fitted curve\npredict_peak(result, 1)  # single peak contribution\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.MultiPeakFitResult","page":"API Reference","title":"SpectroscopyTools.MultiPeakFitResult","text":"MultiPeakFitResult\n\nResult of multi-peak fitting (1 to N peaks with polynomial baseline).\n\nSupports indexing by peak number: result[1] returns first peak's PeakFitResult.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpectroscopyTools.PeakFitResult","page":"API Reference","title":"SpectroscopyTools.PeakFitResult","text":"PeakFitResult\n\nResult of peak fitting with any lineshape model.\n\nAccess parameters by name: result[:center].value, result[:fwhm].err\n\n\n\n\n\n","category":"type"},{"location":"api/#SpectroscopyTools.anharmonicity","page":"API Reference","title":"SpectroscopyTools.anharmonicity","text":"anharmonicity(fit::TASpectrumFit) -> Float64\n\nCompute the anharmonicity (GSB center - ESA center) from a TA spectrum fit. Returns NaN if there is not exactly one ESA and one GSB peak.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.PeakInfo","page":"API Reference","title":"SpectroscopyTools.PeakInfo","text":"PeakInfo\n\nInformation about a detected peak.\n\nFields\n\nposition::Float64 — Peak center in x-units\nintensity::Float64 — Peak height\nprominence::Float64 — How much the peak stands out from surrounding baseline\nwidth::Float64 — Full width at half prominence (FWHP) in x-units\nbounds::Tuple{Float64,Float64} — Left and right edges at half prominence\nindex::Int — Index in the original data array\n\n\n\n\n\n","category":"type"},{"location":"api/#SpectroscopyTools.find_peaks","page":"API Reference","title":"SpectroscopyTools.find_peaks","text":"find_peaks(y; kwargs...) -> Vector{PeakInfo}\nfind_peaks(x, y; kwargs...) -> Vector{PeakInfo}\n\nFind peaks in spectroscopic data.\n\nKeyword Arguments\n\nmin_prominence::Real=0.05 — Minimum prominence as fraction of data range\nmin_width::Real=0 — Minimum peak width in x-units\nmax_width::Real=Inf — Maximum peak width in x-units\nmin_height::Real=-Inf — Minimum peak height (absolute)\nwindow::Int=1 — Comparison window for local maxima detection\nbaseline::Union{Symbol,Nothing}=nothing — Apply baseline correction before peak detection\nbaseline_kw::NamedTuple=NamedTuple() — Keyword arguments for baseline correction\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.peak_table","page":"API Reference","title":"SpectroscopyTools.peak_table","text":"peak_table(peaks::Vector{PeakInfo}) -> String\n\nFormat detected peaks as an aligned text table for terminal display.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.fit_exp_decay","page":"API Reference","title":"SpectroscopyTools.fit_exp_decay","text":"fit_exp_decay(trace::TATrace; n_exp=1, irf=false, irf_width=0.15, t_start=0.0, t_range=nothing)\n\nFit exponential decay to a transient absorption trace.\n\nArguments\n\ntrace: TATrace\nn_exp: Number of exponential components (default 1)\nirf: Include IRF convolution (default false)\nirf_width: Initial guess for IRF σ in ps (default 0.15)\nt_start: Start time for fitting when irf=false (default 0.0)\nt_range: Optional (tmin, tmax) to restrict fit region\n\nReturns\n\nn_exp=1: ExpDecayFit\nn_exp>1: MultiexpDecayFit\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.fit_global","page":"API Reference","title":"SpectroscopyTools.fit_global","text":"fit_global(traces::Vector{TATrace}; n_exp=1, irf_width=0.15, labels=nothing) -> GlobalFitResult\n\nFit multiple traces simultaneously with shared time constant(s) τ.\n\nSupports single-exponential (n_exp=1) and multi-exponential (n_exp>1) global analysis. All traces share the same time constants, IRF width, and time zero, while amplitudes and offsets are fitted per-trace.\n\nKeywords\n\nn_exp::Int=1: Number of exponential components\nirf_width::Float64=0.15: Initial guess for IRF σ in ps\nlabels=nothing: Optional trace labels (defaults to \"Trace 1\", \"Trace 2\", ...)\n\nReturns\n\nGlobalFitResult with shared taus and per-trace amplitudes matrix.\n\nExamples\n\n# Single-exponential global fit\nresult = fit_global([trace_esa, trace_gsb])\n\n# Multi-exponential with 2 shared time constants\nresult = fit_global([trace1, trace2, trace3]; n_exp=2)\nreport(result)\n\n\n\n\n\nfit_global(matrix::TAMatrix; n_exp=1, irf_width=0.15, λ=nothing) -> GlobalFitResult\n\nGlobal analysis of a TAMatrix, extracting traces at each wavelength.\n\nReturns a GlobalFitResult with the wavelengths field populated, enabling decay-associated spectra (DAS) via das(result).\n\nKeywords\n\nn_exp::Int=1: Number of exponential components\nirf_width::Float64=0.15: Initial guess for IRF σ in ps\nλ=nothing: Specific wavelengths to fit. If nothing, fits all wavelengths.\n\nExamples\n\nresult = fit_global(matrix; n_exp=2)\nreport(result)\n\n# Get decay-associated spectra\nspectra = das(result)  # n_exp × n_wavelengths matrix\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.ExpDecayFit","page":"API Reference","title":"SpectroscopyTools.ExpDecayFit","text":"ExpDecayFit\n\nResult of exponential decay fitting with instrument response function convolution.\n\nFields\n\namplitude, tau, t0, sigma, offset, signal_type, residuals, rsquared\n\n\n\n\n\n","category":"type"},{"location":"api/#SpectroscopyTools.MultiexpDecayFit","page":"API Reference","title":"SpectroscopyTools.MultiexpDecayFit","text":"MultiexpDecayFit\n\nResult of multi-exponential decay fitting (n >= 1 components).\n\nFields\n\ntaus::Vector{Float64}: Time constants (sorted fast->slow)\namplitudes::Vector{Float64}: Corresponding amplitudes\nt0, sigma, offset, signal_type, residuals, rsquared\n\nDerived properties\n\nn_exp(fit): Number of exponential components\nweights(fit): Relative amplitude weights (normalized to 100%)\n\n\n\n\n\n","category":"type"},{"location":"api/#SpectroscopyTools.GlobalFitResult","page":"API Reference","title":"SpectroscopyTools.GlobalFitResult","text":"GlobalFitResult\n\nResult of global fitting multiple traces with shared time constants.\n\nSupports single-exponential (nexp=1) and multi-exponential (nexp>1) global analysis with shared τ values and per-trace amplitudes.\n\nFields\n\ntaus::Vector{Float64}: Shared time constants (sorted fast→slow)\nsigma::Float64: Shared IRF width\nt0::Float64: Shared time zero\namplitudes::Matrix{Float64}: Per-trace amplitudes (ntraces × nexp)\noffsets::Vector{Float64}: Per-trace offsets\nlabels::Vector{String}: Trace labels\nwavelengths::Union{Nothing, Vector{Float64}}: Wavelength axis (from TAMatrix input)\nrsquared::Float64: Global R²\nrsquared_individual::Vector{Float64}: Per-trace R²\nresiduals::Vector{Vector{Float64}}: Per-trace residuals\n\nDerived properties\n\nn_exp(fit): Number of exponential components\ndas(fit): Decay-associated spectra (requires TAMatrix input)\n\n\n\n\n\n","category":"type"},{"location":"api/#SpectroscopyTools.das","page":"API Reference","title":"SpectroscopyTools.das","text":"das(fit::GlobalFitResult) -> Matrix{Float64}\n\nReturn the decay-associated spectra (DAS) as an n_exp × n_wavelengths matrix. Each row is the amplitude spectrum for one time constant.\n\nRequires that the fit was performed on a TAMatrix (wavelengths must be available).\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.report","page":"API Reference","title":"SpectroscopyTools.report","text":"report(result)\n\nPrint a formatted summary of a fit result to the terminal.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.als_baseline","page":"API Reference","title":"SpectroscopyTools.als_baseline","text":"als_baseline(y; λ=1e5, p=0.01, maxiter=10, tol=1e-6) -> Vector\n\nAsymmetric Least Squares baseline correction.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.arpls_baseline","page":"API Reference","title":"SpectroscopyTools.arpls_baseline","text":"arpls_baseline(y; λ=1e5, maxiter=100, tol=1e-6) -> Vector\n\nAsymmetrically Reweighted Penalized Least Squares baseline correction.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.snip_baseline","page":"API Reference","title":"SpectroscopyTools.snip_baseline","text":"snip_baseline(y; iterations=40, decreasing=true) -> Vector\n\nSNIP baseline correction using iterative peak clipping.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.correct_baseline","page":"API Reference","title":"SpectroscopyTools.correct_baseline","text":"correct_baseline(y; method=:arpls, kwargs...) -> NamedTuple\n\nCorrect baseline and return both corrected spectrum and baseline.\n\nReturns (y=corrected, baseline=baseline).\n\n\n\n\n\ncorrect_baseline(x, y; kwargs...) -> NamedTuple\n\nVersion that also returns x values for convenience.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.normalize","page":"API Reference","title":"SpectroscopyTools.normalize","text":"normalize(x)\n\nNormalize array by maximum absolute value. Returns zeros if max is zero.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.smooth_data","page":"API Reference","title":"SpectroscopyTools.smooth_data","text":"smooth_data(y; window=3)\n\nApply moving average smoothing to data.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.calc_fwhm","page":"API Reference","title":"SpectroscopyTools.calc_fwhm","text":"calc_fwhm(x, y; smooth_window=5)\n\nCalculate full width at half maximum (FWHM) of the dominant positive peak.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.subtract_spectrum","page":"API Reference","title":"SpectroscopyTools.subtract_spectrum","text":"subtract_spectrum(sample, reference; scale=1.0, interpolate=false)\n\nSubtract a reference spectrum from a sample spectrum.\n\nAccepts AbstractSpectroscopyData types (uses xdata/ydata interface) or any objects with .x and .y fields.\n\nReturns (x=..., y=...) NamedTuple.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.transmittance_to_absorbance","page":"API Reference","title":"SpectroscopyTools.transmittance_to_absorbance","text":"transmittance_to_absorbance(T; percent=false)\n\nConvert transmittance to absorbance: A = -log10(T). Input T is fractional (0 to 1). Use percent=true for percent transmittance.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.absorbance_to_transmittance","page":"API Reference","title":"SpectroscopyTools.absorbance_to_transmittance","text":"absorbance_to_transmittance(A; percent=false)\n\nConvert absorbance to transmittance: T = 10^(-A).\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.npoints","page":"API Reference","title":"SpectroscopyTools.npoints","text":"npoints(d::AbstractSpectroscopyData) -> Int\nnpoints(d::TAMatrix) -> Tuple{Int,Int}\n\nReturn the number of data points. For 1D data, returns an Int. For 2D data (TAMatrix), returns (n_time, n_wavelength).\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.source_file","page":"API Reference","title":"SpectroscopyTools.source_file","text":"source_file(d::AbstractSpectroscopyData) -> String\n\nReturn the source filename for the data.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.title","page":"API Reference","title":"SpectroscopyTools.title","text":"title(d::AbstractSpectroscopyData) -> String\n\nReturn a display title for the data. Defaults to source_file(d).\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.wavenumber_to_wavelength","page":"API Reference","title":"SpectroscopyTools.wavenumber_to_wavelength","text":"wavenumber_to_wavelength(ν̃; output_unit=u\"nm\")\n\nConvert wavenumber (cm⁻¹) to wavelength.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.wavelength_to_wavenumber","page":"API Reference","title":"SpectroscopyTools.wavelength_to_wavenumber","text":"wavelength_to_wavenumber(λ; output_unit=u\"cm^-1\")\n\nConvert wavelength to wavenumber. Input assumed in nm if unitless.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.wavenumber_to_energy","page":"API Reference","title":"SpectroscopyTools.wavenumber_to_energy","text":"wavenumber_to_energy(ν̃; output_unit=u\"eV\")\n\nConvert wavenumber (cm⁻¹) to photon energy.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.wavelength_to_energy","page":"API Reference","title":"SpectroscopyTools.wavelength_to_energy","text":"wavelength_to_energy(λ; output_unit=u\"eV\")\n\nConvert wavelength to photon energy. Input assumed in nm if unitless.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.energy_to_wavelength","page":"API Reference","title":"SpectroscopyTools.energy_to_wavelength","text":"energy_to_wavelength(E; output_unit=u\"nm\")\n\nConvert photon energy to wavelength. Input assumed in eV if unitless.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.linewidth_to_decay_time","page":"API Reference","title":"SpectroscopyTools.linewidth_to_decay_time","text":"linewidth_to_decay_time(Γ; output_unit=u\"ps\")\n\nConvert spectral linewidth (FWHM) to decay time: τ = ℏ/Γ. Input assumed in meV if unitless.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectroscopyTools.decay_time_to_linewidth","page":"API Reference","title":"SpectroscopyTools.decay_time_to_linewidth","text":"decay_time_to_linewidth(τ; output_unit=u\"meV\")\n\nConvert excited-state decay time to natural linewidth (FWHM): Γ = ℏ/τ. Input assumed in ps if unitless.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/chirp_correction/#Chirp-Correction-for-Broadband-Transient-Absorption","page":"Chirp Correction","title":"Chirp Correction for Broadband Transient Absorption","text":"","category":"section"},{"location":"tutorials/chirp_correction/#What-is-chirp-and-why-does-it-matter?","page":"Chirp Correction","title":"What is chirp and why does it matter?","text":"In a broadband transient absorption (TA) experiment, the white-light continuum probe pulse passes through optical elements –- windows, filters, the sample cuvette, and the solvent itself –- before reaching the detector. Each of these materials has a wavelength-dependent refractive index, so different colors travel at different speeds. This effect is called group velocity dispersion (GVD), and the resulting wavelength-dependent arrival time is called chirp.\n\nConcretely, if you look at a raw TA surface (signal vs. time and wavelength), you will see that the signal onset is not a vertical line at t = 0. Instead it traces a curve –- typically with blue wavelengths arriving later than red ones (positive GVD in most materials). This curved onset is the chirp.\n\nIf you don't correct for chirp, your data has two problems:\n\nSpectra at early times are distorted. A spectrum extracted at, say, t = 200 fs doesn't represent a single moment in time –- it's a superposition of signals at different pump-probe delays for different wavelengths.\nKinetic traces at different wavelengths have shifted time zeros. Fitting these traces yields apparent time constants that are convolved with the chirp, biasing your results.","category":"section"},{"location":"tutorials/chirp_correction/#Overview-of-correction-methods","page":"Chirp Correction","title":"Overview of correction methods","text":"Several approaches exist for detecting and correcting chirp. They divide into two categories: methods that determine the chirp curve and correct it as a preprocessing step, and methods that fold chirp into the kinetic model itself.","category":"section"},{"location":"tutorials/chirp_correction/#Preprocessing-approaches","page":"Chirp Correction","title":"Preprocessing approaches","text":"These all follow the same two-stage logic: first measure the wavelength-dependent time zero t_0(lambda), then shift each wavelength trace in time to align them.","category":"section"},{"location":"tutorials/chirp_correction/#Coherent-artifact-/-cross-phase-modulation-(XPM)-detection","page":"Chirp Correction","title":"Coherent artifact / cross-phase modulation (XPM) detection","text":"The most common approach. The sharp, non-resonant coherent artifact that appears around time zero in TA data is wavelength-dependent due to chirp. You find the time-zero position at each wavelength, then fit a smooth function to the resulting chirp curve. This is what SpectroscopyTools implements.\n\nSeveral strategies exist for locating time zero at each wavelength:\n\nMaximum of Delta A: Find the time point where the absolute signal is largest in the early-time window. Simple but can be biased if real dynamics have large amplitude near time zero.\nSteepest slope (maximum of dDelta Adt): Take the numerical derivative and find its extremum. This targets the rising edge of the signal rather than the peak, making it less sensitive to overlapping dynamics. Probably the most widely used variant.\nHalf-rise point: Find where each trace crosses 50% of its early-time extremum. Less sensitive to noise than the derivative method, but assumes a monotonic rise.\nFit a step function convolved with a Gaussian: At each wavelength, fit A cdot texterfc((t - t_0)  sigma) + textoffset. This gives t_0 and the instrument response width sigma simultaneously. Most rigorous, but slow when applied at every wavelength.\nCross-correlation of onset gradients: Cross-correlate the absolute gradient of each wavelength bin against a reference bin (the one with the strongest signal). Since the absolute gradient produces a spike at the onset regardless of whether the signal is positive (GSB) or negative (ESA), this is polarity-independent. Parabolic interpolation on the cross-correlation peak gives sub-time-step precision. This is the default :xcorr method in SpectroscopyTools.","category":"section"},{"location":"tutorials/chirp_correction/#Optical-Kerr-effect-(OKE)-reference-measurement","page":"Chirp Correction","title":"Optical Kerr effect (OKE) reference measurement","text":"Measure the optical Kerr effect in a non-resonant medium (pure solvent, glass) placed at the sample position. The OKE signal is instantaneous, so its peak position vs. wavelength directly traces the chirp curve. This is considered the gold standard because it is independent of sample dynamics, but it requires a separate measurement with a different detection geometry (crossed polarizers).","category":"section"},{"location":"tutorials/chirp_correction/#Two-photon-absorption-(TPA)-reference","page":"Chirp Correction","title":"Two-photon absorption (TPA) reference","text":"Use a thin semiconductor or dye solution where two-photon absorption provides a sharp, instantaneous response. The TPA signal onset traces the chirp curve. Less common than OKE, but useful when the setup geometry makes OKE difficult.","category":"section"},{"location":"tutorials/chirp_correction/#Sellmeier-/-dispersion-calculation","page":"Chirp Correction","title":"Sellmeier / dispersion calculation","text":"Calculate the expected GVD analytically from the known optical elements in the probe path using Sellmeier equations for each material's refractive index. This gives a physics-based chirp curve without any calibration measurement. In practice this is used as a sanity check or starting guess rather than a primary correction, because small alignment differences and unaccounted optics introduce errors.","category":"section"},{"location":"tutorials/chirp_correction/#Hardware-pre-compensation","page":"Chirp Correction","title":"Hardware pre-compensation","text":"Use chirped mirrors, prism compressors, or grism (grating + prism) compressors to pre-compensate the probe GVD so the pulse is nearly transform-limited at the sample. This minimizes chirp before acquisition rather than correcting it afterward. Often combined with a small software correction for residual chirp.","category":"section"},{"location":"tutorials/chirp_correction/#Model-based-approaches","page":"Chirp Correction","title":"Model-based approaches","text":"","category":"section"},{"location":"tutorials/chirp_correction/#Global-analysis-with-chirp-as-a-free-parameter","page":"Chirp Correction","title":"Global analysis with chirp as a free parameter","text":"In global/target analysis (e.g., Glotaran), the chirp parameters are included as free parameters in the kinetic fit. The chirp curve, typically parameterized as a low-order polynomial, is optimized simultaneously with the rate constants and spectral amplitudes.\n\nThis is becoming increasingly popular because:\n\nIt avoids sequential error propagation –- errors in the chirp detection step don't get baked into the \"corrected\" data before the kinetic model sees it.\nThe coherent artifact often overlaps with genuine ultrafast dynamics (solvation, vibrational cooling) in the first few hundred femtoseconds, making algorithmic separation ambiguous.\nSoftware like Glotaran and pyglotaran has made it accessible without custom code.\nIt is self-consistent for publication: one coherent set of parameters rather than a preprocessing step with hidden assumptions.\n\nThe main downside is that the chirp estimate is coupled to the kinetic model. A wrong model can give wrong chirp, and the optimization landscape is more complex. Most groups still do an initial correction as preprocessing, then let the global fit refine the chirp parameters.","category":"section"},{"location":"tutorials/chirp_correction/#Step-by-step-correction-as-a-preprocessing-step","page":"Chirp Correction","title":"Step-by-step correction as a preprocessing step","text":"This section walks through the standard workflow in detail.","category":"section"},{"location":"tutorials/chirp_correction/#Step-1:-Subtract-the-pre-pump-background","page":"Chirp Correction","title":"Step 1: Subtract the pre-pump background","text":"TA is already a difference measurement, so the signal before the pump arrives should be zero. Any residual offset is systematic background (detector dark current, scattered pump light, etc.). Subtracting it improves chirp detection by removing a constant bias.\n\nusing SpectroscopyTools\n\nmatrix_bg = subtract_background(matrix)\n\nsubtract_background averages the signal in the pre-pump region (auto-detected or specified via t_range) and subtracts that baseline from every time point.","category":"section"},{"location":"tutorials/chirp_correction/#Step-2:-Detect-the-chirp-curve","page":"Chirp Correction","title":"Step 2: Detect the chirp curve","text":"SpectroscopyTools provides two detection methods. Both bin the wavelength axis for noise reduction, smooth each bin with a Savitzky-Golay filter, then locate the signal onset.\n\ncal = detect_chirp(matrix_bg)\nreport(cal)\n\nThe default :xcorr method cross-correlates onset gradients against the strongest-signal bin. Use :threshold for simpler half-maximum onset detection:\n\ncal_thr = detect_chirp(matrix_bg; method=:threshold)\n\nKey parameters to adjust:\n\nParameter Default When to change\nbin_width 8 Increase for high-pixel-count CCDs (e.g. 2048 px). 16 or 32 reduces noise.\nmin_signal 0.2 Lower to include weak-signal spectral regions (noisier detection).\norder 3 A 2nd-order polynomial suffices for modest chirp. Use 3 for broadband (> 200 nm) coverage.\nsmooth_window 15 Increase in noisy data. Must be odd.\nthreshold 3.0 MAD multiplier for outlier rejection. Lower = more aggressive rejection.","category":"section"},{"location":"tutorials/chirp_correction/#Step-3:-Inspect-the-detected-points","page":"Chirp Correction","title":"Step 3: Inspect the detected points","text":"Before trusting the calibration, check that the detected chirp points are sensible. The ChirpCalibration stores both the raw detected points and the polynomial fit:\n\ncal.wavelength     # detected wavelength points (nm)\ncal.time_offset    # detected time offset at each point (ps)\ncal.poly_coeffs    # polynomial coefficients (ascending order)\ncal.r_squared      # fit quality\n\npoly = polynomial(cal)  # callable: t_shift = poly(lambda)\npoly(500.0)             # chirp offset at 500 nm\n\nA good calibration has R^2  095 and the detected points should scatter smoothly around the polynomial curve without systematic deviations. If points at the spectral edges look like outliers, the signal there may be too weak –- try lowering min_signal or increasing bin_width.","category":"section"},{"location":"tutorials/chirp_correction/#Step-4:-Apply-the-correction","page":"Chirp Correction","title":"Step 4: Apply the correction","text":"correct_chirp shifts each wavelength column in time using cubic spline interpolation:\n\nmatrix_corrected = correct_chirp(matrix_bg, cal)\n\nFor each wavelength lambda_j, the corrected signal at time t_i is the original signal evaluated at t_i + t_textshift(lambda_j), where t_textshift comes from the calibration polynomial. Cubic B-spline interpolation ensures sharp features (the coherent artifact, fast rise times) are preserved without the broadening that linear interpolation would introduce.\n\nAt the edges of the time axis, where the shifted time falls outside the measured range, the signal is extrapolated as flat (constant value equal to the boundary). Make sure your time window extends well beyond time zero so that the correction doesn't push any wavelength off the edge.","category":"section"},{"location":"tutorials/chirp_correction/#Step-5:-Validate","page":"Chirp Correction","title":"Step 5: Validate","text":"After correction, check three things:\n\nThe TA surface. Plot the corrected Delta A(t lambda) heatmap. The coherent artifact should now appear as a vertical line at t = 0, not a curved streak.\nEarly-time spectra. Extract spectra at several early delays (e.g. t = 01 02 05 ps). Before correction these are distorted by chirp; after correction they should look like physically reasonable spectra without the characteristic dispersive artifact shape.\nKinetics at the spectral extremes. Compare kinetic traces at the blue and red edges. They should now show simultaneous rise times within the instrument response. If one edge is systematically shifted, the polynomial order may be too low or the detection failed at the edges.","category":"section"},{"location":"tutorials/chirp_correction/#Step-6:-Save-the-calibration","page":"Chirp Correction","title":"Step 6: Save the calibration","text":"Store the chirp calibration for reproducibility and for applying to other datasets taken under the same optical conditions:\n\nsave_chirp(\"chirp_cal_2024-01-15.json\", cal)\n\n# Later, or in a different script:\ncal = load_chirp(\"chirp_cal_2024-01-15.json\")\nmatrix_corrected = correct_chirp(new_matrix, cal)\n\nThe JSON file stores the polynomial coefficients, detected points, and all detection parameters so the calibration is fully reproducible.","category":"section"},{"location":"tutorials/chirp_correction/#Common-pitfalls","page":"Chirp Correction","title":"Common pitfalls","text":"Using too narrow a time window for detection. If the detection window doesn't capture the full signal rise at all wavelengths (because of the chirp itself), edge wavelengths get incorrect t_0 values. The auto-detection in SpectroscopyTools accounts for this, but if you set t_range manually, make it generous.\n\nGetting the sign convention wrong. Does t_0  0 mean the blue arrives early or late? Getting this backwards flips the correction and doubles the chirp instead of removing it. In normal materials, the blue arrives later (positive GVD). After correction, check that the surface looks less curved, not more.\n\nCorrecting twice. If the acquisition software already applies a partial chirp correction, applying a second correction on top will overcorrect. Check the raw data before starting.\n\nOverfitting the polynomial. The chirp curve should be smooth. Any high-frequency structure in t_0(lambda) is noise. Use the minimum polynomial order that captures the curvature –- 2nd or 3rd order is almost always sufficient. SpectroscopyTools uses MAD-based outlier rejection to guard against this, but inspecting the residuals is still good practice.\n\nIgnoring the wavelength-dependent IRF. GVD doesn't just shift time zero –- it also temporally broadens the probe pulse at wavelengths far from the continuum center. The correction procedure above fixes the shift but not the broadening. For the most accurate kinetics, you may need a wavelength-dependent instrument response function in your fitting model.","category":"section"},{"location":"tutorials/chirp_correction/#Full-example","page":"Chirp Correction","title":"Full example","text":"using SpectroscopyTools\n\n# Assume `matrix` is a TAMatrix loaded from your data\n# Step 1: Background subtraction\nmatrix_bg = subtract_background(matrix)\n\n# Step 2: Detect chirp\ncal = detect_chirp(matrix_bg; bin_width=16, order=3)\nreport(cal)\n\n# Step 3: Inspect\nprintln(\"R-squared: \", cal.r_squared)\nprintln(\"Number of detected points: \", length(cal.wavelength))\n\n# Step 4: Correct\nmatrix_corrected = correct_chirp(matrix_bg, cal)\n\n# Step 5: Save for reuse\nsave_chirp(\"chirp_calibration.json\", cal)","category":"section"},{"location":"tutorials/chirp_correction/#API-Reference","page":"Chirp Correction","title":"API Reference","text":"See the API Reference page for full docstrings of all chirp functions.","category":"section"},{"location":"#SpectroscopyTools.jl","page":"Home","title":"SpectroscopyTools.jl","text":"A general-purpose spectroscopy analysis toolkit for Julia.\n\nSpectroscopyTools provides peak fitting, baseline correction, exponential decay fitting with IRF deconvolution, chirp correction, and unit conversions for spectroscopic data. It is designed to work with any spectroscopy discipline –- ultrafast, FTIR, Raman, UV-vis, fluorescence –- while keeping a minimal dependency footprint.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"SpectroscopyTools\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using SpectroscopyTools\n\n# Fit peaks in a spectrum\nresult = fit_peaks(wavenumber, absorbance, (2000, 2100))\nreport(result)\n\n# Baseline correction\nbaseline = als_baseline(y; lambda=1e5, p=0.01)\ny_corrected = y .- baseline\n\n# Unit conversions\nwavelength_to_wavenumber(1500u\"nm\")  # -> wavenumber in cm^-1","category":"section"},{"location":"#Package-Overview","page":"Home","title":"Package Overview","text":"Module What it does\nPeak fitting Gaussian, Lorentzian, Pseudo-Voigt via CurveFit.jl\nPeak detection Automatic peak finding via Peaks.jl\nBaseline correction ALS, ARPLS, SNIP, polynomial, Whittaker\nExponential decay Single/multi-exponential with optional IRF convolution\nGlobal fitting Shared parameters across multiple traces\nChirp correction GVD detection and correction for broadband TA\nUnit conversions Wavenumber, wavelength, energy, linewidth interconversion\nSmoothing Savitzky-Golay filtering","category":"section"},{"location":"#Tutorials","page":"Home","title":"Tutorials","text":"Pages = [\"tutorials/chirp_correction.md\"]\nDepth = 2","category":"section"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"See the full API Reference for documentation of all exported functions and types.","category":"section"}]
}
